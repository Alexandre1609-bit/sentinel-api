name: Sentinel CI

#étape 1: Quand ? (les déclancheurs)
#Le robot se réveille quand on pousse sur "main" ou qu'on fait une Pull Request !
on:
  push:
    branches: [ "main" ] # C'est assez explicite en vrai !
  pull_request:
    branches: [ "main" ]

#étape 2: Quoi ? (Les missions)
jobs:
  security-and-quality:
    name: Audit & Test
    runs-on: ubuntu-latest #Ici github nous prête un serveur Linux, pas mal ! 

    steps:
      #A. Le robot récupère le code
      - name: Checkout code
        uses: actions/checkout@v4 #'@v4' : Sécurité de la chaîne de d'approvisionnement. On reste sur la v4, figée et sécurisée.

      #B. Le robot installe Python 3.10
      - name: Set up Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"
      
      #C. Le robot installe les outils (pytest, httpx, pip-audit...)
      - name: Install dépendencies
        run: | #(Pipe) Permet de faire un bloc de texte sur plusieurs lignes ! Sans '|' obligé de faire sur une ligne avec '&&'.
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      #D. Sécurité (Gatekeeper)
      #Si ça échoue ici, la pipeline s'arrêt et on reçoit une alerte.
      - name: Security Audit (Pip-Audit)
        run: pip-audit

      #E. Qualité
      #Le robot lance le test qu'on vient de réussir en local.
      - name: Run unit Tests (Pytest)
        env:
          ADMIN_EMAIL: "robot@test.ci"
          APP_NAME: "Sentinel-CI"
        run: pytest
      
  #étape: 3 Construction et livraison (CD)
  docker-build-and-push:
    needs: [security-and-quality]
    runs-on: ubuntu-latest

    #1. Permissions (sécurité !)
    #On donne le droit au robot d'écrire des "packages" (images)
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      #2. On se connecte au registre
      #Le robot utilise sa carte d'identité temporaire pour entrer
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      #3. On prépare les métadonnées
      #Cette action calcule automatiquement les noms et les tags de l'image
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5 #Ici ça génère automatiquement le tag ":main" (on est sur la branche main)
        with:
          images: ghcr.io/${{ github.repository }}

      #4. Build & Push
      #L'action "officielle" qui construit ET envoie l'image !
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true #On active le CD !! 
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}